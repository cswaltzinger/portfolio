#!/bin/bash


MODE="${MODE:-PROD}"

DB_FILE="${DATA_DB_FILE:-$HOME/.config/data.db.sqlite}"
SEP="${DATA_DB_SEPORATOR:-" "}"
TABLE="${DATA_DB_TABLE_NAME:-"main"}"




### override echo to be used for developer messages
echo(){
    if [ "$MODE" = "DEV" ]; then
        command echo "$@"
    else 
        command echo "$@" > /dev/stderr
    fi
}
if [ "$MODE" = "DEV" ]; then
    DB_FILE="$(realpath .)/data.db"
fi



### value can be one of the two following functions 
TRANSPOSE_CMD=""
print_as_env(){
    print_as_env_helpper(){
        local name=$(basename "$1")
        shift 
        local value="$@"
        printf "%s=%s\n" "$name" "$value"
    }
    while read line; do 
        print_as_env_helpper $line
    done
}

pretty_print(){
    pretty_print_helpper(){
        local name="$1"
        shift 
        local value="$@"
        printf "%s [ %s ]\n" "$name" "$value"
    }
    while read line; do 
        pretty_print_helpper $line
    done
}

# Helper function to execute a SQL command against the database
sqlite_exec() {
    local sql_command="$1"
    if [ -t 1 ]; then
        if [ -z "$TRANSPOSE_CMD" ];then 
            TRANSPOSE_CMD=pretty_print
        fi
        sqlite3 -batch -separator "$SEP" "$DB_FILE" "$sql_command" | $TRANSPOSE_CMD
    else 
        if [ -z "$TRANSPOSE_CMD" ];then 
            sqlite3 -batch -separator "$SEP" "$DB_FILE" "$sql_command" 
        else
            sqlite3 -batch -separator "$SEP" "$DB_FILE" "$sql_command" | $TRANSPOSE_CMD

        fi
    fi
    return $?
}

# --- Core Functions ---

# Function 1: Initializes the database and table
# Creates the database file and the 'main' table.
init() {
    echo "Initializing database at $DB_FILE..."
    # 1. Ensure the directory exists
    mkdir -p "$(dirname $DB_FILE)"

    # 2. Define the SQL command to create the table
    local create_table_sql="CREATE TABLE IF NOT EXISTS $TABLE (
        name TEXT NOT NULL,
        value TEXT,
        UNIQUE(name) ON CONFLICT REPLACE
    );
    CREATE INDEX IF NOT EXISTS idx_name ON $TABLE(name);"
        
    # 3. Execute the SQL command
    sqlite_exec "$create_table_sql"
    
    if [ $? -eq 0 ]; then
        echo "Database initialized successfully." 
    else
        echo "Error: Database initialization failed." 
        return 1
    fi
}


# Function 2: Gets the value of an item
# Arguments: $1 = tag, $2 = name
getInfo() {
    if [ "$#" = "0" ] || [ "$1" = "--all" ] || [ "$1" = "-a" ] || [ "$1" = "all" ]; then
        sqlite_exec "SELECT * FROM $TABLE;"
        return $?
    fi

    local name="$1"
    local values='value'
    if [ -t 1 ] || [ "$TRANSPOSE_CMD" = "print_as_env" ];then
        values='*'
    fi

    if [ "$TRANSPOSE_CMD" = "print_as_env" ];then
        values='*'
    fi



    local select_sql="SELECT $values FROM $TABLE WHERE name LIKE '%$name%';"
    sqlite_exec "$select_sql"
    
    return $?
}

# Function 3: Sets or updates the value of an item
# Arguments: $1 = name, $2 ?= new_value
setInfo() {

    local name="$1"
    local value="$2"
    if [ -z "$value" ]; then
        value=$(cat /dev/stdin)
        # echo "$name = [$value]"
        if [ -z "$value" ]; then
            say not gotten
            echo "please provide a value to set [$name]"
            return 1
        fi
    fi
    



    local insert_sql="INSERT OR REPLACE INTO $TABLE (name, value) VALUES ('$name', '$value');"

    # Use INSERT OR REPLACE to handle both insertion and update in one statement.
    
    sqlite_exec "$insert_sql"
    
    if [ "$?" != "0" ]; then
        echo "$0: Failed to set [$name]." 
        return 1
    fi
}

# Function 4: Removes all table entries with matching tag and name
# Arguments: $1 = name
deleteInfo() {
    if [ -z "$1" ]; then
        echo "Usage: $0 <full variable name>" 
        return 1
    fi

    local name="$1"
    
    local delete_sql="DELETE FROM $TABLE WHERE name='$name';"
    
    sqlite_exec "$delete_sql"
    
    if [ $? -eq 0 ]; then
        echo "Deleted entry for name='$name'."
    else
        echo "Error: Failed to delete information." 
        return 1
    fi
}

_test_shell(){
    rm ./data.db 
    init 
    for color in red green blue orange; do 
        echo setInfo colors/$color "value-$color" 
        setInfo colors/$color "value-$color" 
    done
    echo ""
    getInfo
    printf "\n\n>>> "
    while read line; do 
        eval $line 
        printf "\n>>> "
    done 
}

config(){
    for var in MODE TABLE DB_FILE;do 
        eval "echo -e \"$var:\t\$$var\""
    done
}

MODE=PROD
if [ "$MODE" = "DEV" ]; then
   _test_shell
else
    # TODO: make better with getopts 
    case "$1" in
        -i|--init|init)
            init
            ;;
        
       -e|--env|env|-g|--get|get|-a|--all|all)
            if [[ "-e|--env|env" = *"$1"* ]];then 
                TRANSPOSE_CMD=print_as_env
            fi
            shift
            if [ "$#" -eq 0 ]; then
                getInfo 
            else
                getInfo "$@"
            fi
            ;;

        -s|--set|set)
            shift 
            setInfo "$@"
            ;;

        -d|--delete|delete|del|--rm|--remove)
            shift 
            deleteInfo "$@"
            ;;

        --sql|sql)
            shift 
            sqlite_exec "$@"
            ;;
        clean)
            rm $DB_FILE
            clear 

            ;;
        *)
            if [ -z "$@" ];then
                getInfo
            else 
                eval "$@"
            fi
            ;;
    esac
fi

